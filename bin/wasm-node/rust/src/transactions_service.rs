// Smoldot
// Copyright (C) 2019-2021  Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

//! Background transactions service.
//!
//! The role of the [`TransactionsService`] is to manage the transactions that the user wants to
//! send out, and report about their status.
//!
//! The [`TransactionsService`] is most of the time idle. When the user wants to emit a
//! transaction on the network, it gets reported to the service, which then tries to send it to
//! the peers the node is currently connected to. Afterwards, the service will inspect the stream
//! of best and finalized blocks to find out whether the transaction has been included or not.

use crate::{network_service, sync_service};
use futures::{channel::mpsc, lock::Mutex, prelude::*, stream::FuturesOrdered};
use smoldot::{header, libp2p::peer_id::PeerId, network::protocol::{self, BlockData}};
use std::{collections::HashMap, pin::Pin, sync::Arc};

/// Configuration for a [`TransactionsService`].
pub struct Config {
    /// Closure that spawns background tasks.
    pub tasks_executor: Box<dyn FnMut(Pin<Box<dyn Future<Output = ()> + Send>>) + Send>,

    /// Access to the network, and index of the chain to sync from the point of view of the
    /// network service.
    pub network_service: (Arc<network_service::NetworkService>, usize),

    /// Service responsible for synchronizing the chain.
    pub sync_service: Arc<sync_service::SyncService>,
}

/// See [the module-level documentation](..).
pub struct TransactionsService {
    /// Sending messages to the background task.
    to_background: Mutex<mpsc::Sender<ToBackground>>,
}

impl TransactionsService {
    /// Builds a new service.
    pub async fn new(mut config: Config) -> Self {
        let (to_background, from_foreground) = mpsc::channel(8);

        (config.tasks_executor)(Box::pin(background_task(
            config.network_service.0,
            config.network_service.1,
            config.sync_service,
            from_foreground,
        )));

        TransactionsService {
            to_background: Mutex::new(to_background),
        }
    }

    /// Adds a transaction to the service. The service will try to send it out as soon as
    /// possible.
    ///
    /// The return value of this method is a channel which will receive updates on the state
    /// of the extrinsic. The channel is closed when no new update is expected.
    ///
    /// > **Note**: Dropping the value returned does not cancel sending out the extrinsic.
    pub async fn submit_extrinsic(&self, transaction: &[u8]) -> mpsc::Receiver<TransactionStatus> {
        // TODO: think about the size and full-ness of this channel
        let (updates_report, rx) = mpsc::channel(16);

        self.to_background
            .lock()
            .await
            .send(ToBackground::SubmitTransaction {
                transaction_bytes: transaction.to_owned(),
                updates_report,
            })
            .await
            .unwrap();

        rx
    }
}

/// Update on the state of an extrinsic in the service.
///
/// > **Note**: Because this code isn't an *actual* transactions pool that leverages the runtime,
/// >           some variants (e.g. `Invalid`) are missing compared to the ones that can be found
/// >           in Substrate, as they can't possibly be generated by this implementation.
/// >           Additionally, an equivalent to the `Ready` state in Substrate is missing as it
/// >           is the default state.
#[derive(Debug, Clone)]
pub enum TransactionStatus {
    /// Transaction has been broadcasted to the given peers.
    Broadcast(Vec<PeerId>),
    /// Detected a best block that contains this transaction.
    InBlock([u8; 32]),
    /// Can be sent after [`TransactionStatus::InBlock`] to notify that a re-org happened and the
    /// current best tree of blocks no longer contains the transaction.
    ///
    /// Contains the same block as was previously passed in [`TransactionStatus::InBlock`].
    Retracted([u8; 32]),
    /// Transaction has been dropped because the service was full.
    Dropped,
    /// Transaction has been included in a finalized block.
    Finalized([u8; 32]),
    /// Transaction is not in a finalized block, but is included in the 512th ancestor of the
    /// current best block. This can happen if finality has stalled or is simply not available
    /// on the chain.
    FinalityTimeout([u8; 32]),
}

#[derive(Clone)]
enum BlockStatus {
    Pending,
    Downloaded,
    Finalized,
}

#[derive(Clone)]
struct Block {
    hash: Vec<u8>,
    body: Option<BlockData>,
    status: BlockStatus,
}

impl Block {
    fn transactions(&self) -> Option<Vec<Vec<u8>>> {
        self.body.clone().map(|data| data.body).flatten()
    }

    fn hash(&self) -> [u8; 32] {
        let mut hash = [0; 32];
        hash.copy_from_slice(&self.hash);
        hash
    }
}

#[derive(Clone)]
struct Transaction {
    bytes: Vec<u8>,
    updates_report: mpsc::Sender<TransactionStatus>,
    block: Option<Block>,
    received_at_finalized_block: u64,
}

/// Message sent from the foreground service to the background.
enum ToBackground {
    SubmitTransaction {
        transaction_bytes: Vec<u8>,
        updates_report: mpsc::Sender<TransactionStatus>,
    },
}

/// Background task running in parallel of the front service.
async fn background_task(
    network_service: Arc<network_service::NetworkService>,
    network_chain_index: usize,
    sync_service: Arc<sync_service::SyncService>,
    mut from_foreground: mpsc::Receiver<ToBackground>,
) {
    // A stream of blocks which have to be downloaded in order to check
    // pending transactions against.
    let mut blocks_to_download = FuturesOrdered::new();
    // A list of block hashes which this task receives to prevent
    // downloading the blocks multiple times.
    let mut known_blocks = HashMap::<Vec<u8>, Block>::new();

    let mut pending_transactions =
        HashMap::<_, _, fnv::FnvBuildHasher>::with_capacity_and_hasher(16, Default::default());

    // TODO: must periodically re-send transactions that aren't included in block yet
    // TODO: DROP transaction in case we fall behind

    let (_, mut best_block_receiver) = sync_service.subscribe_best().await;
    let (current_finalized_block_header, mut finalized_block_receiver) = sync_service.subscribe_finalized().await;

    // The current finalized_block_number is the start of our "timer" which
    // is used to decide whether to rebroadcast a specific transaction.
    let mut finalized_block_number = match header::decode(&current_finalized_block_header) {
        Ok(header) => header.number,
        Err(_) => 0,
    };

    loop {
        futures::select! {
            message = from_foreground.next().fuse() => {
                match message {
                    None => return,
                    Some(ToBackground::SubmitTransaction {
                        transaction_bytes,
                        mut updates_report,
                    }) => {
                        let peers_sent = network_service
                            .clone()
                            .announce_transaction(network_chain_index, &transaction_bytes)
                            .await;

                        if !peers_sent.is_empty() {
                            let _ = updates_report
                                .send(TransactionStatus::Broadcast(peers_sent))
                                .await;
                        }

                        let transaction_bytes: Vec<u8> = match header::transaction_decode(&transaction_bytes) {
                            Ok(decoded) => decoded,
                            Err(_) => continue,
                        };

                        // Create a pending transaction which was received at the last known
                        // finalized block. At every consecutive finalized block, the transactions
                        // are checked to figure out which ones haven't been included in any block
                        // and based on that we decide to rebroadcast after a specific block threshold
                        // has been reached.
                        pending_transactions.insert(transaction_bytes.clone(), Transaction {
                            bytes: transaction_bytes,
                            updates_report,
                            block: None,
                            received_at_finalized_block: finalized_block_number,
                        });
                    }
                }
            },
            best_header = best_block_receiver.select_next_some() => {
                // Not interested in best block updates in case
                // we don't have transactions in-flight.
                if pending_transactions.is_empty() {
                    known_blocks.clear();
                    continue;
                }

                let best_hash = header::hash_from_scale_encoded_header(&best_header);

                let block = Block {
                    hash: best_hash.to_vec(),
                    status: BlockStatus::Pending,
                    body: None,
                };
                known_blocks.insert(best_hash.to_vec(), block);
                blocks_to_download.push(download_block(network_service.clone(), network_chain_index, best_hash));
            },
            finalized_header = finalized_block_receiver.select_next_some() => {
                // Not interested in best block updates in case
                // we don't have transactions in-flight.
                if pending_transactions.is_empty() {
                    known_blocks.clear();
                    continue;
                }

                let finalized_header = match header::decode(&finalized_header) {
                    Ok(header) => header,
                    Err(_) => continue,
                };
                finalized_block_number = finalized_header.number;

                let finalized_hash = finalized_header.hash().to_vec();

                match known_blocks.get_mut(&finalized_hash) {
                    Some(block) => {
                        block.status = BlockStatus::Finalized;
                        let mut found_transactions = transactions_in_block(block, &mut pending_transactions);
                        if !found_transactions.is_empty() {
                            for transaction in found_transactions.iter_mut() {
                                transaction.block = Some(block.clone());
                            }
                            notify_transactions(found_transactions.clone(), TransactionStatus::Finalized(block.hash())).await;
                            clean_finalized_transactions(&mut pending_transactions, found_transactions);
                        }
                    },
                    None => {
                        // We did not receive this block's notification when it
                        // was current best block.
                        let block = Block {
                            hash: finalized_hash.clone(),
                            status: BlockStatus::Finalized,
                            body: None,
                        };
                        blocks_to_download.push(download_block(network_service.clone(), network_chain_index, finalized_header.hash()));
                        known_blocks.insert(finalized_hash, block);
                    }
                }
            },
            downloaded_block = blocks_to_download.select_next_some() => {
                let downloaded_block_data: BlockData = match downloaded_block {
                    Ok(block_data) => block_data,
                    Err(_) => continue,
                };
                match known_blocks.get_mut(&downloaded_block_data.hash.to_vec()) {
                    Some(block) => {
                        block.body = Some(downloaded_block_data);
                        let mut found_transactions = transactions_in_block(block, &mut pending_transactions);

                        for transaction in found_transactions.iter_mut() {
                            // If a certain transaction was already found
                            // in a different block, then it must have been retracted.
                            if let Some(transaction_block) = &transaction.block {
                                notify_transactions(vec![transaction.clone()], TransactionStatus::Retracted(transaction_block.hash())).await
                            }
                            transaction.block = Some(block.clone());
                        }

                        // A block download could have been initiated at the finalized notification.
                        // Therefore, in this case we send the finalized status for that specific
                        // transaction.
                        let status = match block.status {
                            BlockStatus::Finalized => TransactionStatus::Finalized(block.hash()),
                            _ => {
                                block.status = BlockStatus::Downloaded;
                                TransactionStatus::InBlock(block.hash())
                            },
                        };

                        if !found_transactions.is_empty() {
                            notify_transactions(found_transactions.clone(), status.clone()).await;
                        }

                        match status {
                            TransactionStatus::Finalized(_) => {
                                clean_finalized_transactions(&mut pending_transactions, found_transactions);
                            },
                            _ => {}
                        }
                    },
                    // No notification has been received for this downloaded block
                    // This shouldn't happen!
                    _ => unreachable!()
                }
            },
        }
    }
}

fn clean_finalized_transactions(
    pending_transactions: &mut HashMap<Vec<u8>, Transaction, fnv::FnvBuildHasher>,
    finalized_transactions: Vec<Transaction>,
) {
    for transaction in finalized_transactions {
        pending_transactions.remove(&transaction.bytes);
    }
}

async fn download_block(
    network_service: Arc<network_service::NetworkService>,
    network_chain_index: usize,
    block_hash: [u8; 32],
) -> Result<BlockData, ()> {
    // Block bodies and justifications aren't stored locally. Ask the network.
    network_service
        .clone()
        .block_query(
            network_chain_index,
            block_hash,
            protocol::BlocksRequestFields {
                header: true,
                body: true,
                justification: true,
            },
        )
        .await
}

fn transactions_in_block(
    block: &Block,
    transactions: &mut HashMap<Vec<u8>, Transaction, fnv::FnvBuildHasher>,
) -> Vec<Transaction> {
    let block_transactions = match block.transactions() {
        Some(block_transactions) => block_transactions,
        None => vec![],
    };
    if block_transactions.len() <= 1 {
        return vec![];
    }

    let mut found_transactions = vec![];
    for (transaction_bytes, transaction) in transactions.iter_mut() {
        if block_transactions.iter().skip(1).filter(|t| **t == *transaction_bytes).count() > 0 {
            found_transactions.push(transaction.clone());
        }
    }
    found_transactions
}

async fn notify_transactions(transactions: Vec<Transaction>, status: TransactionStatus) {
    for mut transaction in transactions {
        let _ = transaction
            .updates_report
            .send(status.clone())
            .await;
    }
}
